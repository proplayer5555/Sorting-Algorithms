#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/* διάσταση βοηθητικού πίνακα */
#define maxN 200000

/* δήλωση τύπου αντικειμένων για ταξινόμηση */
typedef int item;

#define key(A) (A) /* το κλειδί της ταξινόμησης */
#define less(A, B) (key(A) < key(B)) /* σύγκριση κλειδιών */
#define exch(A, B) { item t = A; A = B; B = t; } /* αντιμετάθεση κλειδιών */
#define compexch(A, B) if (less(A, B)) exch(A, B) /* σύγκριση και αντιμετάθεση κλειδιών */

void insertionsort2(item *a, int n);
/* Αλγόριθμος ταξινόμησης με εισαγωγή (αποδοτική υλοποίηση) */
void insertionsort(item *a, int n);

/* Εκτύπωση στοιχείων πίνακα */
void display1(item *a, int n);

/* Αλγόριθμος ταξινόμησης με διαχωρισμό */
void quicksort(item *a, int l, int r);

/* Βοηθητική συνάρτηση διαμέρισης */
int partition(item *a, int l, int r);

/* Εκτύπωση στοιχείων πίνακα */
void display2(item *a, int n);

/* βοηθητικός πίνακας */
item aux[maxN];

/* Αλγόριθμος ταξινόμησης με συγχώνευση */
void mergesort(item *a, int l, int r);

/* Βοηθητική συνάρτηση συγχώνευσης */
void merge(item *a, int l, int m, int r);

/* Εκτύπωση στοιχείων πίνακα */
void display3(item *a, int n);


int main() {
	//Ορίζουμε τις μεταβλητές μερικές int για τις for μας, μερικούς μετρητές ,δείκτες για την δυναμική δέσμευση και double μεταβλητές για υπολογίζουμε τον χρόνο και κάποιες τύπου clock
	int i,j,k,q=0,w=0,e=0;
	int *a,*b,*c;
	double sum=0,sum2=0,sum3=0;
	double cpu_time_used_for_insertionsort;
	double cpu_time_used_for_quicksort;
	double cpu_time_used_for_mergesort;
	clock_t start1, end1, start2, end2, start3 , end3;
	
    for(i=20000;i<=200000;i=i+20000)//μια for για να αλλάζει τις διαστάσεις από 20.000 εώς 200.000 με βήμα 20.000
	{
		for(j=0;j<10;j++)
		{
			a = (item *)malloc(i*sizeof(item));//δυναμική δέσμευση μνήμης και έλεγχος στις άλλες τρεις γραμμές αν έγινε επιτυχώς αλλιώς εμφανίζει μύνημα λάθους.
			if(a==NULL)
			{
				printf("Error while allocating memory!!!!!!!!!");
				return 0;
			}
			b = (item *)malloc(i*sizeof(item));//δυναμική δέσμευση μνήμης και έλεγχος στις άλλες τρεις γραμμές αν έγινε επιτυχώς αλλιώς εμφανίζει μύνημα λάθους.
			if(b==NULL)
			{
				printf("Error while allocating memory!!!!!!!!!");
				return 0;
			}
			
			c = (item *)malloc(i*sizeof(item));//δυναμική δέσμευση μνήμης και έλεγχος στις άλλες τρεις γραμμές αν έγινε επιτυχώς αλλιώς εμφανίζει μύνημα λάθους.
			if(c==NULL)
			{
				printf("Error while allocating memory!!!!!!!!!");
				return 0;
			}
			srand(j*i);
			for(k=0;k<i;k++)//γέμισμα του πίνακα με τυχαιόυς αριθμούς
			{
				a[k]= rand();
				b[k]=a[k];
				c[k]=a[k];
			}
			
			start1 = clock();//αρχίζουμε το clock 
		
		    insertionsort(a, i);//καλούμε την insertionsort να κάνει την ταξινομήση 
			
			end1 = clock();//τελειώνουμε το clock
		
		    cpu_time_used_for_insertionsort= (double)(end1 - start1) / (CLOCKS_PER_SEC);//κάνουμε την πράκη για τον χρόνο
		    
		    sum= sum + cpu_time_used_for_insertionsort;//αποθηκεύουομε τον χρόνο στο sum
		    
		    start2 = clock();//αρχίζουμε το clock 
	
		    quicksort(b,0,i);//καλούμε την insertionsort να κάνει την ταξινομήση 
			
			end2 = clock();//τελειώνουμε το clock
		
		    cpu_time_used_for_quicksort= (double)(end2 - start2) / (CLOCKS_PER_SEC);//κάνουμε την πράκη για τον χρόνο
		    
		    sum2 = sum2 + cpu_time_used_for_quicksort;//αποθηκεύουομε τον χρόνο στο sum
		    
		    start3 = clock();//αρχίζουμε το clock 
	
		    mergesort(c,0,i-1);//καλούμε την insertionsort να κάνει την ταξινομήση 
			
			end3 = clock();//τελειώνουμε το clock
		
		    cpu_time_used_for_mergesort= (double)(end3 - start3) / (CLOCKS_PER_SEC);//κάνουμε την πράκη για τον χρόνο
		    
		    sum3= sum3 + cpu_time_used_for_mergesort;//αποθηκεύουομε τον χρόνο στο sum
		
		}
		
		printf("O mesos oros xronoy poy etreje thn %d fora einai :(insertionsort)%lf\n", q+1,sum/(double)10);//διαιρούμε με το 10 για να βρούμε τον μέσο όρο
		q++;
		sum=0;
		printf("O mesos oros xronoy poy etreje thn %d fora einai:(quicksort)%lf\n",w+1,sum2/(double)10);//διαιρούμε με το 10 για να βρούμε τον μέσο όρο	
		w++;
		sum2=0;
		printf("O mesos oros xronoy poy etreje thn %d fora einai:(mergesort)%lf\n",e+1,sum3/(double)10);	//διαιρούμε με το 10 για να βρούμε τον μέσο όρο
		e++;
		sum3=0;
	}
	
    free(a);
    free(b);
    free(c);
	return 0;
}

/* Λειτουργία: Αλγόριθμος ταξινόμησης με εισαγωγή (μη αποδοτική υλοποίηση)
Είσοδος: Ο πίνακας προς ταξινόμηση και το μέγεθος του πίνακα
Έξοδος: Ένας ταξινομημένος πίνακας */
void insertionsort2(item *a, int n) {
	int i, j;
	/* ταξινόμηση όλων των αντικειμένων */
	for (i = 1; i < n; i++) {
		/* σύγκριση του αντικειμένου i με όλα τα αντικείμενα στα αριστερά του */
		for (j = i; j > 0; j--) {
			compexch(a[j], a[j - 1]); /* σύγκριση και αντιμετάθεση αντικειμένων */
		}
	}
}

/* Λειτουργία: Αλγόριθμος ταξινόμησης με εισαγωγή (αποδοτική υλοποίηση)
Είσοδος: Ο πίνακας προς ταξινόμηση και το μέγεθος του πίνακα
Έξοδος: Ένας ταξινομημένος πίνακας */
void insertionsort(item *a, int n) {
	int i, j;
	item temp;
	/* μετακίνηση του μικρότερου στοιχείου στην αρχή του πίνακα για να παίξει το ρόλο φρουρού */
	for (i = 1; i < n; i++) {
		compexch(a[i], a[0]);
	}
	/* ταξινόμηση όλων των αντικειμένων */
	for (i = 2; i < n; i++) {
		j = i;
		temp = a[i];
		/* σύγκριση του αντικειμένου i με όλα τα αντικείμενα στα αριστερά του μέχρι να βρει το πρώτο μεγαλύτερο αντικείμενο */
		while (less(temp, a[j - 1])) {
			a[j] = a[j - 1];
			j--;
		}
		a[j] = temp;
	}
}

/* Λειτουργία: Εκτύπωση στοιχείων πίνακα
Είσοδος: Ο πίνακας και το μέγεθος του πίνακα
Έξοδος: - */
void display1(item *a, int n) {
	int i;
	printf("-----\n");
	for (i = 0; i < n; i++) {
		printf("%d ", a[i]);
	}
	printf("\n-----\n");
}

/* Λειτουργία: Αλγόριθμος ταξινόμησης με διαχωρισμό
Είσοδος: Ο πίνακας προς ταξινόμηση και οι δείκτες l και r που δείχνουν το κομμάτι του πίνακα προς ταξινόμηση 
Έξοδος: Ένας ταξινομημένος πίνακας */
void quicksort(item a[], int l, int r) {
	int i;
	if (r <= l) /* τερματισμός αναδρομικής κλήσης */
		return;
	/* διαμερισμός πίνακα */
	i = partition(a, l, r);
	/* αναδρομική κλήση για το πρώτο κομμάτι */
	quicksort(a, l, i - 1);
	/* αναδρομική κλήση για το δεύτερο κομμάτι */
	quicksort(a, i + 1, r);
}

/* Λειτουργία: Βοηθητική συνάρτηση διαμέρισης
Είσοδος: Ο πίνακας προς ταξινόμηση και οι δείκτες l και r που δείχνουν το κομμάτι του πίνακα προς διαμέριση 
Έξοδος: Ένας πίνακας όπου τα στοιχεία το στοιχείο a[r] βρίσκεται στην τελική του θέση μέσα στον πίνακα, κανένα από τα στοιχεία a[1], ., a[r-1] δεν είναι μεγαλύτερο από το a[r] και κανένα από τα στοιχεία a[r+1], ., a[r] δεν είναι μικρότερο από το a[r]
 */
int partition(item a[], int l, int r) {
	int i = l, j = r - 1; /* δείκτες σάρωσης */
	item v = a[r]; /* δείκτης διαχωρισμού */
	while (1) { /* ατέρμων βρόγχος */
		/* μετακίνηση αριστερού δείκτη σάρωσης μέχρι να βρεθεί μεγαλύτερο ή ίσο στοιχείο */
		while (less(a[i], v)) i++; 
		/* μετακίνηση δεξιού δείκτη σάρωσης μέχρι να βρεθεί μικρότερο στοιχείο ή να συναντηθούν οι δύο δείκτες */
		while (less(v, a[j])) {
			j--;
			if (j == l)
				break;
		}
		/* αν συναντήθηκαν οι δείκτες ή ο αριστερός προσπέρασε τον δεξιό, τότε ο πίνακας είναι σε τάξη */
		if (i >= j)
			break;
		/* αντιμετάθεση στοιχείων */
		exch(a[i], a[j]);
		/* κίνηση δεικτών σάρωσης κατά μία θέση */
		i++;
		j--;
	}
	/* τοποθέτηση του στοιχείου διαχωρισμού στην σωστή θέση */
	exch(a[i], a[r]);
	return i;
}

/* Λειτουργία: Εκτύπωση στοιχείων πίνακα
Είσοδος: Ο πίνακας και το μέγεθος του πίνακα
Έξοδος: - */
void display2(item *a, int n) {
	int i;
	printf("-----\n");
	for (i = 0; i < n; i++) {
		printf("%d ", a[i]);
	}
	printf("\n-----\n");
}

/* Λειτουργία: Αλγόριθμος ταξινόμησης με συγχώνευση (αναδρομική υλοποίηση)
Είσοδος: Ο πίνακας προς ταξινόμηση και οι δείκτες l και r που δείχνουν το κομμάτι του πίνακα προς ταξινόμηση
Έξοδος: Ένας ταξινομημένος πίνακας */
void mergesort(item a[], int l, int r) {
	/* τερματισμός αναδρομικής κλήσης */
	if (r <= l) return;
	/* εύρεση σημείο διαχωρισμού */
	int m = (r + l) / 2;
	/* αναδρομική κλήση για το πρώτο μισό */
	mergesort(a, l, m);
	/* αναδρομική κλήση για το δεύτερο μισό */
	mergesort(a, m + 1, r);
	/* συγχώνευση κομματιών */
	merge(a, l, m, r);
}

/* Λειτουργία: Βοηθητική συνάρτηση συγχώνευσης
Είσοδος: Ο πίνακας προς ταξινόμηση, οι δείκτες l και r που δείχνουν το κομμάτι του πίνακα προς συγχώνευση, και ο δείκτης m που δείχνει που σταματάει ο πρώτος υποπίνακας
Έξοδος: Ένας ταξινομημένος πίνακας που συγχωνεύσει τους δύο υποπίνακες
*/
void merge(item a[], int l, int m, int r) {
	int i, j, k;
	/* αντιγραφή στον βοηθητικό πίνακα του πρώτου υποπίνακα */
	for (i = m + 1; i > l; i--) 
		aux[i - 1] = a[i - 1]; 
	/* αντιγραφή στον βοηθητικό πίνακα του αντιστραμμένου δεύτερου υποπίνακα */
	for (j = m; j < r; j++) 
		aux[r + m - j] = a[j + 1];
	/* συγχώνευση */
	for (k = l; k <= r; k++)
		if (less(aux[j], aux[i])) 
			a[k] = aux[j--]; 
		else a[k] = aux[i++];
}

/* Λειτουργία: Εκτύπωση στοιχείων πίνακα
Είσοδος: Ο πίνακας και το μέγεθος του πίνακα
Έξοδος: - */
void display3(item *a, int n) {
	int i;
	printf("-----\n");
	for (i = 0; i < n; i++) {
		printf("%d ", a[i]);
	}
	printf("\n-----\n");
}
